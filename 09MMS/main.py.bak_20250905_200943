#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
市场微结构仿真引擎 (MMS) - 主入口文件
负载均衡器实现，基于ZeroMQ DEALER/ROUTER模式

作者: NeuroTrade Nexus 开发团队
版本: 1.0.0
创建时间: 2024-12-01
"""

import asyncio
import logging
import signal
import sys
import threading
import time
from concurrent.futures import ThreadPoolExecutor
from typing import Dict, List, Optional

import zmq
import zmq.asyncio
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from loguru import logger
from pydantic import BaseModel
from uvicorn import Config, Server

from src.core.config import settings
from src.core.database import init_database
from src.api.routes import router as api_router
from src.services.load_balancer import LoadBalancer
from src.utils.logger import setup_logger
from src.utils.exceptions import ErrorHandler


class HealthResponse(BaseModel):
    """健康检查响应模型"""

    status: str
    timestamp: float
    version: str
    workers: int


class StatusResponse(BaseModel):
    """系统状态响应模型"""

    service_status: str
    worker_count: int
    queue_length: int
    avg_response_time: float
    memory_usage: float
    cpu_usage: float


class MMSApplication:
    """MMS应用程序主类"""

    def __init__(self):
        self.app = FastAPI(
            title="市场微结构仿真引擎 (MMS)",
            description="NeuroTrade Nexus 交易系统的虚拟现实引擎",
            version="1.0.0",
            docs_url="/docs" if settings.DEBUG else None,
            redoc_url="/redoc" if settings.DEBUG else None,
        )
        self.load_balancer: Optional[LoadBalancer] = None
        self.server: Optional[Server] = None
        self.shutdown_event = threading.Event()

        # 设置CORS
        allowed_origins = (
            ["*"]
            if settings.DEBUG
            else [f"http://{host}" for host in settings.ALLOWED_HOSTS]
            + [f"https://{host}" for host in settings.ALLOWED_HOSTS]
        )
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=allowed_origins,
            allow_credentials=True,
            allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
            allow_headers=["*"],
        )

        # 注册路由
        self.setup_routes()

        # 设置错误处理
        self.setup_error_handlers()

        # 设置信号处理
        self.setup_signal_handlers()

    def setup_routes(self):
        """设置API路由"""

        @self.app.get("/health", response_model=HealthResponse)
        async def health_check():
<<<<<<< HEAD
            """健康检查端点"""
            worker_count = (
                self.load_balancer.get_worker_count()
                if self.load_balancer
                else 0
            )
            return HealthResponse(
                status="healthy",
=======
            """健康检查接口"""
            worker_count = 0
            if self.load_balancer:
                worker_count = len(self.load_balancer.workers)

            return HealthResponse(
                status="running",
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])
                timestamp=time.time(),
                version="1.0.0",
                workers=worker_count,
            )

        @self.app.get("/status", response_model=StatusResponse)
        async def get_status():
<<<<<<< HEAD
            """获取系统状态"""
            if not self.load_balancer:
                raise HTTPException(status_code=503, detail="Load balancer not ready")

            stats = self.load_balancer.get_stats()
            return StatusResponse(
                service_status="running",
                worker_count=stats.get("worker_count", 0),
                queue_length=stats.get("queue_length", 0),
                avg_response_time=stats.get("avg_response_time", 0.0),
                memory_usage=stats.get("memory_usage", 0.0),
                cpu_usage=stats.get("cpu_usage", 0.0),
            )
=======
            """系统状态接口"""
            if not self.load_balancer:
                raise HTTPException(
                    status_code=503, detail="Load balancer not initialized"
                )

            status = await self.load_balancer.get_status()
            return StatusResponse(**status)
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])

        # 注册API路由
        self.app.include_router(api_router, prefix="/api/v1")

    def setup_error_handlers(self):
        """设置错误处理器"""
        error_handler = ErrorHandler()

<<<<<<< HEAD
        @self.app.exception_handler(Exception)
        async def global_exception_handler(request: Request, exc: Exception):
            return await error_handler.handle_exception(request, exc)

        @self.app.exception_handler(HTTPException)
        async def http_exception_handler(request: Request, exc: HTTPException):
            return await error_handler.handle_http_exception(request, exc)

        @self.app.exception_handler(ValueError)
        async def value_error_handler(request: Request, exc: ValueError):
            return await error_handler.handle_value_error(request, exc)
=======
        @self.app.exception_handler(HTTPException)
        async def http_exception_handler(request, exc: HTTPException):
            """HTTP异常处理器"""
            logger.warning(f"HTTP异常: {exc.status_code} - {exc.detail}")
            return {
                "success": False,
                "error": {
                    "code": exc.status_code,
                    "message": exc.detail,
                    "timestamp": time.time(),
                },
            }

        @self.app.exception_handler(Exception)
        async def global_exception_handler(request, exc: Exception):
            """全局异常处理器"""
            error_response = error_handler.create_error_response(
                exc, status_code=500, include_traceback=settings.DEBUG
            )
            logger.error(f"未处理的异常: {exc}", exc_info=True)
            return error_response
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])

    def setup_signal_handlers(self):
        """设置信号处理器"""

        def signal_handler(signum, frame):
<<<<<<< HEAD
            logger.info(f"Received signal {signum}, shutting down gracefully...")
=======
            logger.info(f"接收到信号 {signum}，开始优雅关闭...")
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])
            self.shutdown_event.set()

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

    async def start_load_balancer(self):
        """启动负载均衡器"""
        try:
            self.load_balancer = LoadBalancer(
                frontend_port=settings.FRONTEND_PORT,
                backend_port=settings.BACKEND_PORT,
                worker_count=settings.WORKER_COUNT,
            )
<<<<<<< HEAD
            await self.load_balancer.start()
            logger.info("Load balancer started successfully")
        except Exception as e:
            logger.error(f"Failed to start load balancer: {e}")
=======

            logger.info("启动负载均衡器...")
            await self.load_balancer.start()

        except Exception as e:
            logger.error(f"负载均衡器启动失败: {e}")
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])
            raise

    async def start_web_server(self):
        """启动Web服务器"""
        try:
            config = Config(
                app=self.app,
                host=settings.HOST,
<<<<<<< HEAD
                port=settings.PORT,
                log_level=settings.LOG_LEVEL.lower(),
                access_log=settings.DEBUG,
            )
            self.server = Server(config)
            await self.server.serve()
        except Exception as e:
            logger.error(f"Failed to start web server: {e}")
=======
                port=settings.HTTP_PORT,
                log_level="info" if settings.DEBUG else "warning",
                access_log=settings.DEBUG,
            )

            self.server = Server(config)
            logger.info(f"启动HTTP服务器在 {settings.HOST}:{settings.HTTP_PORT}")
            await self.server.serve()

        except Exception as e:
            logger.error(f"Web服务器启动失败: {e}")
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])
            raise

    async def run(self):
        """运行应用程序"""
        try:
<<<<<<< HEAD
            # 设置日志
            setup_logger()
            logger.info("Starting MMS Application...")

            # 初始化数据库
            await init_database()
            logger.info("Database initialized")

            # 启动负载均衡器
            await self.start_load_balancer()

            # 启动Web服务器
            server_task = asyncio.create_task(self.start_web_server())

            # 等待关闭信号
            while not self.shutdown_event.is_set():
                await asyncio.sleep(1)

            # 优雅关闭
            logger.info("Shutting down...")
            await self.cleanup()

        except Exception as e:
            logger.error(f"Application error: {e}")
            sys.exit(1)

    async def cleanup(self):
        """清理资源"""
        try:
            if self.load_balancer:
                await self.load_balancer.stop()
                logger.info("Load balancer stopped")

            if self.server:
                self.server.should_exit = True
                logger.info("Web server stopped")

        except Exception as e:
            logger.error(f"Error during cleanup: {e}")
=======
            # 初始化数据库
            logger.info("初始化数据库...")
            await init_database()

            # 创建任务
            tasks = [
                asyncio.create_task(self.start_load_balancer()),
                asyncio.create_task(self.start_web_server()),
            ]

            # 等待任务完成或关闭信号
            done, pending = await asyncio.wait(
                tasks, return_when=asyncio.FIRST_COMPLETED
            )

            # 取消未完成的任务
            for task in pending:
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass

        except Exception as e:
            logger.error(f"应用程序运行错误: {e}")
            raise
        finally:
            await self.cleanup()

    async def cleanup(self):
        """清理资源"""
        logger.info("开始清理资源...")

        if self.load_balancer:
            await self.load_balancer.stop()

        if self.server:
            self.server.should_exit = True

        logger.info("资源清理完成")
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])


def main():
    """主函数"""
<<<<<<< HEAD
    try:
        app = MMSApplication()
        asyncio.run(app.run())
    except KeyboardInterrupt:
        logger.info("Application interrupted by user")
    except Exception as e:
        logger.error(f"Application failed to start: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
=======
    # 设置日志
    setup_logger()

    logger.info("=" * 50)
    logger.info("市场微结构仿真引擎 (MMS) 启动中...")
    logger.info(f"环境: {settings.APP_ENV}")
    logger.info(f"调试模式: {settings.DEBUG}")
    logger.info(f"工作进程数: {settings.WORKER_COUNT}")
    logger.info("=" * 50)

    # 创建并运行应用
    app = MMSApplication()

    try:
        asyncio.run(app.run())
    except KeyboardInterrupt:
        logger.info("接收到键盘中断，正在关闭...")
    except Exception as e:
        logger.error(f"应用程序异常退出: {e}")
        sys.exit(1)
    finally:
        logger.info("MMS应用程序已关闭")


if __name__ == "__main__":
    main()
>>>>>>> 4d5ab11 (chore: init repo (private) [skip ci])
