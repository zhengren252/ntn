# AI智能体驱动交易系统 - 核心设计理念与全局规范

> **重要说明**: 本文档的内容已整合到 `MASTER-SYSTEM-SPEC-V1.2.md` 主规范文档中。主规范文档是项目的唯一权威技术纲领，当存在冲突时以主规范文档为准。本文档作为详细的技术实现参考保留。

**主规范文档**: `MASTER-SYSTEM-SPEC-V1.2.md` - 项目唯一权威技术纲领

## 1. 核心设计理念

### 1.1 微服务架构原则
- **单一职责**：每个服务专注于特定的业务功能，确保高内聚低耦合
- **服务自治**：各服务独立部署、独立扩展、独立故障恢复
- **数据隔离**：每个服务管理自己的数据，避免数据库层面的强耦合
- **接口标准化**：统一使用ZeroMQ和HTTP REST API进行服务间通信

### 1.2 人机协作理念
- **AI增强决策**：AI提供数据分析和策略建议，人类进行最终决策确认
- **智能化自动执行**：在预设规则范围内实现自动化交易执行
- **异常人工介入**：关键节点和异常情况下保留人工干预机制
- **持续学习优化**：基于交易结果和市场反馈持续优化AI模型

### 1.3 风险优先原则
- **多层风控体系**：实时监控、预警机制、自动熔断、人工确认
- **资金安全保障**：严格的资金管理和头寸控制机制
- **合规性要求**：满足金融监管要求，确保交易合规性
- **容错设计**：系统具备故障自愈能力，确保服务连续性

## 2. 系统架构规范

### 2.1 模组划分标准

系统按功能职责划分为14个独立模组：

| 模组类型 | 模组名称 | 核心职责 |
|---------|---------|----------|
| 基础服务 | 01APIForge | API统一管理工厂 |
| 基础服务 | 02DataSpider | 信息源爬虫 |
| 基础服务 | 03ScanPulse | 扫描器 |
| 核心业务 | 04OptiCore | 策略优化 |
| 核心业务 | 05-07TradeGuard | 交易执行铁三角 |
| 核心业务 | 08NeuroHub | 总控 |
| 核心业务 | 09MMS | 市场微结构仿真引擎 |
| 辅助服务 | 10ReviewGuard | 人工审核模块 |
| 前端界面 | 11ASTS Console | 智能化指挥中心 |
| 核心服务 | 12TACoreService | 交易代理核心服务 |
| AI服务 | 13AI Strategy Assistant | AI策略研究助手 |
| 监控服务 | 14Observability Center | 可观测性中心 |

#### 基础服务层 (Infrastructure Layer)
- **APIForge (01)**：统一API网关，负责请求路由和负载均衡
- **TACoreService (12)**：AI交易核心服务，集成TradingAgents-CN能力

#### 数据信息层 (Data & Information Layer)
- **DataSpider (02)**：市场数据爬虫，负责多源数据采集
- **ScanPulse (03)**：信号扫描服务，实时监控市场机会

#### 决策执行层 (Decision & Execution Layer)
- **OptiCore (04)**：策略优化引擎，负责参数调优和回测
- **Trader (07)**：交易执行服务，负责订单管理和执行
- **RiskControl (06)**：风险控制服务，实时风险监控和熔断
- **Finance (09)**：财务管理服务，资金管理和绩效分析
- **ReviewGuard (05)**：审查守卫服务，交易前风险审查

#### 全局指挥层 (Global Command Layer)
- **NeuroHub (08)**：神经中枢，系统协调和状态管理
- **MMS (10)**：主控管理系统，全局配置和监控
- **ASTS Console (11)**：前端控制台，用户交互界面

#### 支持服务层 (Support Services Layer)
- **AI Assistant (13)**：AI策略研究助理，智能分析和建议
- **Observability Center (14)**：可观测性中心，监控和日志分析

### 2.2 通信协议规范

#### ZeroMQ通信标准
```python
# 服务端模式 (REP)
import zmq

context = zmq.Context()
socket = context.socket(zmq.REP)
socket.bind("tcp://*:5555")

while True:
    message = socket.recv_json()
    # 处理业务逻辑
    response = process_request(message)
    socket.send_json(response)
```

#### 客户端模式 (REQ)
```python
# 客户端模式
import zmq

context = zmq.Context()
socket = context.socket(zmq.REQ)
socket.connect("tcp://tacore_service:5555")

request = {
    "action": "analyze_strategy",
    "params": {"symbol": "BTCUSDT", "timeframe": "1h"}
}
socket.send_json(request)
response = socket.recv_json()
```

#### HTTP API标准
```python
# FastAPI标准实现
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

class StrategyRequest(BaseModel):
    name: str
    config: dict
    description: str = None

@app.post("/api/strategy/create")
async def create_strategy(request: StrategyRequest):
    try:
        # 业务逻辑处理
        result = await strategy_service.create(request)
        return {"success": True, "data": result}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### 2.3 数据格式规范

#### JSON消息格式
```json
{
  "timestamp": "2024-01-01T00:00:00Z",
  "service": "tacore_service",
  "action": "analyze_strategy",
  "request_id": "req_123456789",
  "params": {
    "symbol": "BTCUSDT",
    "timeframe": "1h",
    "strategy_type": "mean_reversion"
  },
  "metadata": {
    "version": "1.0",
    "source": "opticore"
  }
}
```

#### 响应格式标准
```json
{
  "success": true,
  "timestamp": "2024-01-01T00:00:01Z",
  "request_id": "req_123456789",
  "data": {
    "analysis_result": {
      "signal": "buy",
      "confidence": 0.85,
      "recommended_position": 0.1
    }
  },
  "error": null,
  "metadata": {
    "processing_time_ms": 150,
    "model_version": "v2.1"
  }
}
```

## 3. 开发规范

### 3.1 代码规范

#### Python代码规范
- 遵循PEP 8编码规范
- 使用类型注解提高代码可读性
- 函数和类必须包含docstring文档
- 使用pytest进行单元测试，覆盖率不低于80%

```python
from typing import Dict, List, Optional
from datetime import datetime

class StrategyAnalyzer:
    """策略分析器类，负责策略性能分析和优化建议"""
    
    def __init__(self, config: Dict[str, any]) -> None:
        """初始化策略分析器
        
        Args:
            config: 分析器配置参数
        """
        self.config = config
        self.logger = self._setup_logger()
    
    def analyze_performance(self, 
                          trades: List[Dict], 
                          benchmark: Optional[str] = None) -> Dict[str, float]:
        """分析策略性能指标
        
        Args:
            trades: 交易记录列表
            benchmark: 基准指标名称
            
        Returns:
            包含性能指标的字典
            
        Raises:
            ValueError: 当交易记录为空时抛出异常
        """
        if not trades:
            raise ValueError("交易记录不能为空")
            
        # 实现分析逻辑
        return self._calculate_metrics(trades, benchmark)
```

#### TypeScript/React代码规范
- 使用TypeScript严格模式
- 组件使用函数式组件和Hooks
- 使用ESLint和Prettier保证代码质量
- 组件必须包含PropTypes或TypeScript接口定义

```typescript
interface StrategyCardProps {
  strategy: {
    id: string;
    name: string;
    status: 'active' | 'inactive' | 'paused';
    performance: {
      totalReturn: number;
      sharpeRatio: number;
      maxDrawdown: number;
    };
  };
  onEdit: (strategyId: string) => void;
  onDelete: (strategyId: string) => void;
}

const StrategyCard: React.FC<StrategyCardProps> = ({ 
  strategy, 
  onEdit, 
  onDelete 
}) => {
  const handleEdit = useCallback(() => {
    onEdit(strategy.id);
  }, [strategy.id, onEdit]);

  return (
    <Card className="p-4 border rounded-lg shadow-sm">
      <CardHeader>
        <CardTitle>{strategy.name}</CardTitle>
        <Badge variant={strategy.status === 'active' ? 'success' : 'secondary'}>
          {strategy.status}
        </Badge>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-3 gap-4">
          <MetricItem 
            label="总收益" 
            value={`${(strategy.performance.totalReturn * 100).toFixed(2)}%`} 
          />
          <MetricItem 
            label="夏普比率" 
            value={strategy.performance.sharpeRatio.toFixed(2)} 
          />
          <MetricItem 
            label="最大回撤" 
            value={`${(strategy.performance.maxDrawdown * 100).toFixed(2)}%`} 
          />
        </div>
      </CardContent>
      <CardFooter>
        <Button onClick={handleEdit} variant="outline" className="mr-2">
          编辑
        </Button>
        <Button onClick={() => onDelete(strategy.id)} variant="destructive">
          删除
        </Button>
      </CardFooter>
    </Card>
  );
};
```

### 3.2 测试规范

#### 单元测试标准
```python
import pytest
from unittest.mock import Mock, patch
from src.services.strategy_analyzer import StrategyAnalyzer

class TestStrategyAnalyzer:
    """策略分析器测试类"""
    
    @pytest.fixture
    def analyzer(self):
        """测试夹具：创建策略分析器实例"""
        config = {"risk_free_rate": 0.02, "benchmark": "SPY"}
        return StrategyAnalyzer(config)
    
    @pytest.fixture
    def sample_trades(self):
        """测试夹具：示例交易数据"""
        return [
            {"date": "2024-01-01", "return": 0.05, "quantity": 100},
            {"date": "2024-01-02", "return": -0.02, "quantity": 100},
            {"date": "2024-01-03", "return": 0.03, "quantity": 100}
        ]
    
    def test_analyze_performance_success(self, analyzer, sample_trades):
        """测试策略性能分析成功场景"""
        result = analyzer.analyze_performance(sample_trades)
        
        assert "total_return" in result
        assert "sharpe_ratio" in result
        assert "max_drawdown" in result
        assert isinstance(result["total_return"], float)
        assert result["total_return"] > 0
    
    def test_analyze_performance_empty_trades(self, analyzer):
        """测试空交易记录异常处理"""
        with pytest.raises(ValueError, match="交易记录不能为空"):
            analyzer.analyze_performance([])
    
    @patch('src.services.strategy_analyzer.calculate_sharpe_ratio')
    def test_analyze_performance_with_mock(self, mock_sharpe, analyzer, sample_trades):
        """测试使用Mock的性能分析"""
        mock_sharpe.return_value = 1.5
        
        result = analyzer.analyze_performance(sample_trades)
        
        mock_sharpe.assert_called_once()
        assert result["sharpe_ratio"] == 1.5
```

#### 集成测试标准
```python
import pytest
import asyncio
from httpx import AsyncClient
from src.main import app

@pytest.mark.asyncio
class TestStrategyAPI:
    """策略API集成测试"""
    
    async def test_create_strategy_integration(self):
        """测试策略创建完整流程"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            # 创建策略
            strategy_data = {
                "name": "测试策略",
                "config": {"period": 20, "threshold": 0.02},
                "description": "集成测试策略"
            }
            
            response = await client.post("/api/strategy/create", json=strategy_data)
            assert response.status_code == 200
            
            result = response.json()
            assert result["success"] is True
            assert "strategy_id" in result
            
            strategy_id = result["strategy_id"]
            
            # 验证策略已创建
            get_response = await client.get(f"/api/strategy/{strategy_id}")
            assert get_response.status_code == 200
            
            strategy = get_response.json()["data"]
            assert strategy["name"] == "测试策略"
            assert strategy["config"]["period"] == 20
```

### 3.3 部署规范

#### Docker配置标准
```dockerfile
# 多阶段构建示例
FROM python:3.11-slim as builder

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir --user -r requirements.txt

FROM python:3.11-slim as runtime

# 创建非root用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

WORKDIR /app

# 复制依赖
COPY --from=builder /root/.local /home/appuser/.local
COPY --chown=appuser:appuser . .

# 设置环境变量
ENV PATH=/home/appuser/.local/bin:$PATH
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# 切换到非root用户
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/health')"

EXPOSE 8000

CMD ["python", "main.py"]
```

#### Docker Compose配置标准
```yaml
version: '3.8'

services:
  tacore_service:
    build:
      context: ./12TACoreService
      dockerfile: Dockerfile
    container_name: tacore_service
    ports:
      - "5555:5555"
    environment:
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=INFO
    volumes:
      - ./12TACoreService/data:/app/data
      - ./12TACoreService/logs:/app/logs
    networks:
      - asts_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import zmq; print('OK')"]
      interval: 30s
      timeout: 10s
      retries: 3
    depends_on:
      redis:
        condition: service_healthy

  redis:
    image: redis:7-alpine
    container_name: asts_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - asts_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  redis_data:

networks:
  asts_network:
    driver: bridge
```

## 4. 质量保证规范

### 4.1 代码审查标准
- 所有代码变更必须通过Pull Request流程
- 至少需要一名高级开发者的审查批准
- 自动化测试必须全部通过
- 代码覆盖率不得低于80%

### 4.2 持续集成流程
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run linting
      run: |
        flake8 src/ tests/
        black --check src/ tests/
        mypy src/
    
    - name: Run tests
      run: |
        pytest tests/ --cov=src --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
    
    - name: Build Docker image
      run: |
        docker build -t asts/service:${{ github.sha }} .
    
    - name: Run integration tests
      run: |
        docker-compose -f docker-compose.test.yml up --abort-on-container-exit
```

### 4.3 监控和告警规范
- 所有服务必须暴露健康检查端点
- 关键业务指标必须配置监控和告警
- 日志必须结构化，便于分析和查询
- 分布式链路追踪覆盖所有服务调用

```python
# 监控指标示例
from prometheus_client import Counter, Histogram, Gauge

# 业务指标
trade_orders_total = Counter('trade_orders_total', 'Total number of trade orders', ['status', 'symbol'])
trade_execution_duration = Histogram('trade_execution_duration_seconds', 'Trade execution duration')
active_strategies = Gauge('active_strategies_count', 'Number of active strategies')

# 使用示例
def execute_trade(order):
    with trade_execution_duration.time():
        try:
            result = trading_service.execute(order)
            trade_orders_total.labels(status='success', symbol=order.symbol).inc()
            return result
        except Exception as e:
            trade_orders_total.labels(status='failed', symbol=order.symbol).inc()
            raise
```